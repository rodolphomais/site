<div class="postagem">
	<h2 class="titulo-postagem">Conceitos básicos do Controle de Versão</h2>
	<p class="hora-data">22/09/2016 16:20</p>
	<h5 class="titulo-postagem">O Repositório</h5><br/>
	<p id="sobre">No centro do sistema de controlo de versões é um repositório, que é a central de armazenamento de dados do referido sistema. O repositório normalmente armazena informações sob a forma de uma árvore de arquivos -a hierarquia de arquivos e diretórios. Qualquer número de clientes se conectar ao repositório e, em seguida, ler ou escrever para esses arquivos. Ao gravar dados, um cliente torna a informação disponível para os outros; por dados de leitura, o cliente recebe informações de outras pessoas.</p>
	<p id="sobre">Quando um cliente lê dados do repositório, ele normalmente vê apenas a versão mais recente da árvore de arquivos. Mas o que faz um cliente de controle de versão interessante é que ele também tem a capacidade de solicitar estados anteriores do sistema de arquivos a partir do repositório. Um cliente de controle de versão pode fazer perguntas históricas, como " O que este directório contém última quarta-feira? " E " Quem foi a última pessoa que alterou este arquivo, e que mudanças ele fez? " Estes são os tipos de perguntas que estão no coração de qualquer sistema de controle de versão.</p>
	<h2 class="titulo-postagem">Modelo de controles<h2><br/>
	<p id="sobre">Todo sistema de controle de versão precisa resolver algumas problemas fundamentais: como o sistema vai permitir aos usuários compartilhar a informação, mas prevenindo que um não atrapalhe o outro? É muito fácil para os usuários acidentalmente sobreescrever as modificações de outros no repositório.</p>
	<h2 class="titulo-postagem">O problema do compartilhamento de arquivo<h2><br/>
	<p id="sobre">Considere o cenário: suponha que nós temos dois usuários, Harry e Sally. Cada um deles decide editar o mesmo arquivo no mesmo repositório ao mesmo tempo. Se Harry salvar suas alterações no repositório primeiro, é possível que (alguns tempo depois) Sally poderia acidentalmente sobreescrever as alterações com sua versão do arquivo. Enquanto a versão do arquivo do Harry se perderia para sempre (porque o sistema guarda cada modificação), qualquer alteração que Harry fez não estariam presentes na nova versão do arquivo de Sally, porque ela nunca viu as modificações do Harry. O trabalho do Harry foi perdido - ou no mínimo estaria na versão mais recente - e provavelmente por acidente. Esta é definitivamente um situação que nós queremos evitar!</p>
	<h2 class="titulo-postagem">A solução Alocar-Modificar-Desalocar</h2><br/>
	<p id="sobre">Muitos sistemas de controle de versão usam o modelo alocar-modificar-desalocar para resolver este problema, o qual é uma solução simples. Em cada sistema, o repositório permite somente uma pessoa por vez modificar o arquivo. Primeiro Harry deve alocar o arquivo antes que possa fazer as alterações. Alocar um arquivo é como um controle de biblioteca/ se Harry alocou o arquivo, então Sally não pode fazer qualquer alteração nele. Se ela tentar alocar o arquivo, o repositório vai negar essa solicitação. Tudo que ela pode fazer é ler o arquivo, e esperar até que Harry acabe as suas alterações e libere o arquivo. Depois que Harry desalocar o arquivo, sua vez acaba, e então é a vez de Sally alocar o arquivo e fazer suas alterações.</p>
	<h2 id="titulo-postagem">A solução Copiar-Modificar-Unificar</h2><br/>
	<p id="sobre">Subversion, CVS, e muitos outros sistemas de controle de versão usar um copy-modify-merge modelo como uma alternativa ao bloqueio. Neste modelo, os contatos de clientes de cada usuário do repositório do projeto e cria uma cópia de trabalho pessoal. Os usuários então trabalham simultaneamente e independentemente, modificando suas cópias privadas. Finalmente, as cópias privadas são fundidos em uma nova versão, final. O sistema de controle de versão freqüentemente ajuda com a fusão, mas em última análise, um ser humano é responsável por fazer isso acontecer corretamente.</p><br/>
	<p id="sobre">Aqui vai um exemplo. Digamos que Harry e Sally criam cada um uma cópia de trabalho de um mesmo projeto, copiado do repositório. Eles trabalham ao mesmo tempo, e fazem modificações em um mesmo arquivo A em suas cópias. Sally salva suas alterações no repositório primeiro. Quando Harry tenta salvar suas modificações após Sally, o repositório informa a ele que o arquivo A está desatualizado. Em outras palavras, o arquivo A do repositório tem alguma alteração desde a última vez que ele foi copiado. Então Harry é questionado sobre a unificação das modificações no repositório serem inseridas em sua cópia do arquivo A. Oportunamente as modicações de Sally não foram sobreescritas pelas dele; uma vez que ele unificou ambas as alterações, ele salva a sua cópia no repositório.</p><br/>
	<p id="sobre">Mas o que acontece se as alterações de Sally se sobrepoem sobre as alterações de Harry? O que então deve ser feito? Esta situação é chamada de conflito, e em geral isto não é um problema. Quando Harry for questionado sobre a unificação das últimas alterações no repositório em sua cópia de trabalho, sua cópia do arquivo A de qualquer maneira é marcada como conflitante: ele verá todas as modificações em conflito, e manualmente resolverá. Entenda que o software não pode resolver automaticamente os conflitos; somente humanos são capazes de entender quais são as escolhas lógicas a serem tomadas. Uma vez que Harry manualmente resolveu o que estava se sobreponde (talvez precise discutir o conflito com Sally!), ele pode seguramente salvar o arquivo unificado de volta no repositório.</p><br/>
	<p id="sobre">O modelo copiar-modificar-unificar pode parecer bagunçado, mas na prática, isto funciona grandemente. Usuários podem trabalhar paralelamente, sem esperar por outros. Quando eles trabalham num mesmo arquivo, a maioria das alterações não se sobrepoem; conflitos são pouco frequentes. E na maioria das vezes o tempo que leva para resolver os conflitos é muito menor que o tempo perdido em um sistema de alocação.</p><br/>
	<p id="sobre">No final das contas, tudo isso acaba em um ponto crítico: comunicação entre os usuários. Quando os usuários não se comunicam direito, aumenta-se os conflitos sintáticos e semênticos. Nenhum sistema pode forçar uma perfeita comunicação, nenhum sistema pode detectar conflitos de semântica. Então não há porque se entusiasmar com falsas promessas de que um sistema de alocação evitará conflitos; na prática, alocações parecem restringir a produtividade mais que qualquer outra cosa.</p><br/>
	<p id="sobre">Existe uma situação em comum onde o modelo alocar-modificar-desalocar se torna melhor, e é com arquivos que não são unificáveis. Por exemplo, se seu repositório contém alguns arquivos de imagens, e duas pessoas mudam a imagem ao mesmo tempo, não há nenhuma maneira de combinar as alterações. Ou Harry ou Sally perderá sua alteração.</p>
	<hr>
	<p id="autor">
		<a href="http://svnbook.red-bean.com/en/1.7/svn.basic.version-control-basics.html" target="_blank">Subversion 1.7</a>
	</p>
</div>
<nav>
	<ul class="pager">
		<li><a href="#" onclick="carregar('postagens_principal2.html');">Anterior</a></li>
	</ul>
</nav>