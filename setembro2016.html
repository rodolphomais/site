<div class="postagem">
	<h2 class="titulo-postagem">Sobre o Git</h2>
	<p class="hora-data">19/09/2016 13:15</p>
	<p id="sobre">Enfim, em poucas palavras, o que é Git? Essa é uma seção importante para assimilar, pois se você entender o que é Git e os fundamentos de como ele funciona, será muito mais fácil utilizá-lo de forma efetiva. À medida que você aprende a usar o Git, tente não pensar no que você já sabe sobre outros VCSs como Subversion e Perforce; assim você consegue escapar de pequenas confusões que podem surgir ao usar a ferramenta. Apesar de possuir uma interface parecida, o Git armazena e pensa sobre informação de uma forma totalmente diferente desses outros sistemas; entender essas diferenças lhe ajudará a não ficar confuso ao utilizá-lo.</p>
	<h2 class="titulo-postagem">Snapshots, E Não Diferenças</h2><br/>
	<p id="sobre">A maior diferença entre Git e qualquer outro VCS (Subversion e similares inclusos) está na forma que o Git trata os dados. Conceitualmente, a maior parte dos outros sistemas armazena informação como uma lista de mudanças por arquivo. Esses sistemas (CVS, Subversion, Perforce, Bazaar, etc.) tratam a informação que mantém como um conjunto de arquivos e as mudanças feitas a cada arquivo ao longo do tempo. Git não pensa ou armazena sua informação dessa forma. Ao invés disso, o Git considera que os dados são como um conjunto de snapshots (captura de algo em um determinado instante, como em uma foto) de um mini-sistema de arquivos. Cada vez que você salva ou consolida (commit) o estado do seu projeto no Git, é como se ele tirasse uma foto de todos os seus arquivos naquele momento e armazenasse uma referência para essa captura. Para ser eficiente, se nenhum arquivo foi alterado, a informação não é armazenada novamente - apenas um link para o arquivo idêntico anterior que já foi armazenado. A figura 1-5 mostra melhor como o Git lida com seus dados.</p><br/>
	<p id="sobre">Essa é uma distinção importante entre Git e quase todos os outros VCSs. Isso leva o Git a reconsiderar quase todos os aspectos de controle de versão que os outros sistemas copiaram da geração anterior. Também faz com que o Git se comporte mais como um mini-sistema de arquivos com algumas poderosas ferramentas construídas em cima dele, ao invés de simplesmente um VCS. Nós vamos explorar alguns dos benefícios que você tem ao lidar com dados dessa forma.</p>
	<h2 id="titulo-postagem">Quase Todas Operações São Locais</h2><br/>
	<p id="sobre">A maior parte das operações no Git precisam apenas de recursos e arquivos locais para operar — geralmente nenhuma outra informação é necessária de outro computador na sua rede. Se você está acostumado a um CVCS onde a maior parte das operações possui latência por conta de comunicação com a rede, esse aspecto do Git fará com que você pense que os deuses da velocidade abençoaram o Git com poderes sobrenaturais. Uma vez que você tem todo o histórico do projeto no seu disco local, a maior parte das operações parece ser quase instantânea.</p><br/>
	<p id="sobre">Por exemplo, para navegar no histórico do projeto, o Git não precisa requisitar ao servidor o histórico para que possa apresentar a você — ele simplesmente lê diretamente de seu banco de dados local. Isso significa que você vê o histórico do projeto quase instantaneamente. Se você quiser ver todas as mudanças introduzidas entre a versão atual de um arquivo e a versão de um mês atrás, o Git pode buscar o arquivo de um mês atrás e calcular as diferenças localmente, ao invés de ter que requisitar ao servidor que faça o cálculo, ou puxar uma versão antiga do arquivo no servidor remoto para que o cálculo possa ser feito localmente.</p><br/>
	<p id="sobre">Isso também significa que há poucas coisas que você não possa fazer caso esteja offline ou sem acesso a uma VPN. Se você entrar em um avião ou trem e quiser trabalhar, você pode fazer commits livre de preocupações até ter acesso a rede novamente para fazer upload. Se você estiver indo para casa e seu cliente de VPN não estiver funcionando, você ainda pode trabalhar. Em outros sistemas, fazer isso é impossível ou muito trabalhoso. No Perforce, por exemplo, você não pode fazer muita coisa quando não está conectado ao servidor; e no Subversion e CVS, você pode até editar os arquivos, mas não pode fazer commits das mudanças já que sua base de dados está offline. Pode até parecer que não é grande coisa, mas você pode se surpreender com a grande diferença que pode fazer.</p>
	<hr>
	<p id="autor">
		<a href="https://git-scm.com/" target="_blank">Git</a>
	</p>
</div>
<div class="postagem">
	<h2 class="titulo-postagem">Controle de Mudanças</h2>
	<p class="hora-data">20/09/2016 09:30</p>
	<p id="sobre">Uma das principais soluções para o controle de mudanças é o Bugzilla, um software free que controla basicamente bugs (erros encontrados em softwares). No entanto, ele pode ser utilizado para controlar também as mudanças ou novas solicitações de software demandadas pelos usuários. Esta ferramenta é poderosa e estável, em uso em centenas de projetos e empresas no mundo todo: NASA, AOL/TW, Redhat, Conectiva, CNet, Mozilla, Gnome. O Bugzila é software livre. Pode ser customizado para sua necessidade. Este software está em contínuo desenvolvimento, e funcionalidade nova e interessante é adicionada diariamente. Tem suporte excelente via email, news, e online via IRC </p>
	<h2 class="titulo-postagem">Integração Contínua</h2><br/>
	<p id="sobre">A Integração Contínua surgiu como parte das práticas da metodologia ágil XP (Extreme Programming), tendo como foco o desenvolvimento de software em ciclos menores, proporcionando melhor resposta a alterações e inclusão de novos requisitos. Mas a prática da Integração Contínua não se limita apenas a equipes utilizando a metodologia XP ou metodologias ágeis, trata-se de um conjunto de boas práticas que também podem ser adotadas em metodologias de desenvolvimento convencionais. A Integração Contínua tem como ideia principal a diminuição dos riscos através do monitoramento constante das alterações, mantendo a integração frequente do código. Esta atividade passa a fazer parte do processo de desenvolvimento, sendo considerada como um procedimento normal e corriqueiro. A integração do código deve ocorrer com a maior frequência possível, idealmente a cada alteração efetuada, pois em caso de problema, o conjunto de modificações em que a falha está inserida é menor, facilitando a identificação e correção do(s) erro(s). Para que a integração seja efetiva, é necessário verificar o funcionamento do código após as modificações, e para atender esta necessidade, o desenvolvimento em conjunto com a realização de testes é fundamental, de preferência com a adoção da metodologia TDD (Test Driven Development). Como resultado da execução de uma integração bem sucedida, conseguimos atingir os seguintes benefícios:</p>
	<ul>
		<li>Garantia que o código compila e que as funcionalidades testadas mantêm sua integridade e funcionamento esperados;</li>
		<li>Uma potencial versão do software, que pode ser utilizada, por exemplo, pela equipe de QA para execução de testes.</li>
	</ul>
	<hr>
	<p id="autor">
		<a href="https://www.bugzilla.org/" target="_blank">Bugzilla</a>
		<a href="http://www.devmedia.com.br/integracao-continua-da-teoria-a-pratica/28284" target="_blank">Sobre Integração Contínua</a>
	</p>
</div>
<div class="postagem">
	<h2 class="titulo-postagem">Conceitos básicos do Controle de Versão</h2>
	<p class="hora-data">22/09/2016 16:20</p>
	<h5 class="titulo-postagem">O Repositório</h5><br/>
	<p id="sobre">No centro do sistema de controlo de versões é um repositório, que é a central de armazenamento de dados do referido sistema. O repositório normalmente armazena informações sob a forma de uma árvore de arquivos -a hierarquia de arquivos e diretórios. Qualquer número de clientes se conectar ao repositório e, em seguida, ler ou escrever para esses arquivos. Ao gravar dados, um cliente torna a informação disponível para os outros; por dados de leitura, o cliente recebe informações de outras pessoas.</p>
	<p id="sobre">Quando um cliente lê dados do repositório, ele normalmente vê apenas a versão mais recente da árvore de arquivos. Mas o que faz um cliente de controle de versão interessante é que ele também tem a capacidade de solicitar estados anteriores do sistema de arquivos a partir do repositório. Um cliente de controle de versão pode fazer perguntas históricas, como " O que este directório contém última quarta-feira? " E " Quem foi a última pessoa que alterou este arquivo, e que mudanças ele fez? " Estes são os tipos de perguntas que estão no coração de qualquer sistema de controle de versão.</p>
	<h2 class="titulo-postagem">Modelo de controles<h2><br/>
	<p id="sobre">Todo sistema de controle de versão precisa resolver algumas problemas fundamentais: como o sistema vai permitir aos usuários compartilhar a informação, mas prevenindo que um não atrapalhe o outro? É muito fácil para os usuários acidentalmente sobreescrever as modificações de outros no repositório.</p>
	<h2 class="titulo-postagem">O problema do compartilhamento de arquivo<h2><br/>
	<p id="sobre">Considere o cenário: suponha que nós temos dois usuários, Harry e Sally. Cada um deles decide editar o mesmo arquivo no mesmo repositório ao mesmo tempo. Se Harry salvar suas alterações no repositório primeiro, é possível que (alguns tempo depois) Sally poderia acidentalmente sobreescrever as alterações com sua versão do arquivo. Enquanto a versão do arquivo do Harry se perderia para sempre (porque o sistema guarda cada modificação), qualquer alteração que Harry fez não estariam presentes na nova versão do arquivo de Sally, porque ela nunca viu as modificações do Harry. O trabalho do Harry foi perdido - ou no mínimo estaria na versão mais recente - e provavelmente por acidente. Esta é definitivamente um situação que nós queremos evitar!</p>
	<h2 class="titulo-postagem">A solução Alocar-Modificar-Desalocar</h2><br/>
	<p id="sobre">Muitos sistemas de controle de versão usam o modelo alocar-modificar-desalocar para resolver este problema, o qual é uma solução simples. Em cada sistema, o repositório permite somente uma pessoa por vez modificar o arquivo. Primeiro Harry deve alocar o arquivo antes que possa fazer as alterações. Alocar um arquivo é como um controle de biblioteca/ se Harry alocou o arquivo, então Sally não pode fazer qualquer alteração nele. Se ela tentar alocar o arquivo, o repositório vai negar essa solicitação. Tudo que ela pode fazer é ler o arquivo, e esperar até que Harry acabe as suas alterações e libere o arquivo. Depois que Harry desalocar o arquivo, sua vez acaba, e então é a vez de Sally alocar o arquivo e fazer suas alterações.</p>
	<h2 id="titulo-postagem">A solução Copiar-Modificar-Unificar</h2><br/>
	<p id="sobre">Subversion, CVS, e muitos outros sistemas de controle de versão usar um copy-modify-merge modelo como uma alternativa ao bloqueio. Neste modelo, os contatos de clientes de cada usuário do repositório do projeto e cria uma cópia de trabalho pessoal. Os usuários então trabalham simultaneamente e independentemente, modificando suas cópias privadas. Finalmente, as cópias privadas são fundidos em uma nova versão, final. O sistema de controle de versão freqüentemente ajuda com a fusão, mas em última análise, um ser humano é responsável por fazer isso acontecer corretamente.</p><br/>
	<p id="sobre">Aqui vai um exemplo. Digamos que Harry e Sally criam cada um uma cópia de trabalho de um mesmo projeto, copiado do repositório. Eles trabalham ao mesmo tempo, e fazem modificações em um mesmo arquivo A em suas cópias. Sally salva suas alterações no repositório primeiro. Quando Harry tenta salvar suas modificações após Sally, o repositório informa a ele que o arquivo A está desatualizado. Em outras palavras, o arquivo A do repositório tem alguma alteração desde a última vez que ele foi copiado. Então Harry é questionado sobre a unificação das modificações no repositório serem inseridas em sua cópia do arquivo A. Oportunamente as modicações de Sally não foram sobreescritas pelas dele; uma vez que ele unificou ambas as alterações, ele salva a sua cópia no repositório.</p><br/>
	<p id="sobre">Mas o que acontece se as alterações de Sally se sobrepoem sobre as alterações de Harry? O que então deve ser feito? Esta situação é chamada de conflito, e em geral isto não é um problema. Quando Harry for questionado sobre a unificação das últimas alterações no repositório em sua cópia de trabalho, sua cópia do arquivo A de qualquer maneira é marcada como conflitante: ele verá todas as modificações em conflito, e manualmente resolverá. Entenda que o software não pode resolver automaticamente os conflitos; somente humanos são capazes de entender quais são as escolhas lógicas a serem tomadas. Uma vez que Harry manualmente resolveu o que estava se sobreponde (talvez precise discutir o conflito com Sally!), ele pode seguramente salvar o arquivo unificado de volta no repositório.</p><br/>
	<p id="sobre">O modelo copiar-modificar-unificar pode parecer bagunçado, mas na prática, isto funciona grandemente. Usuários podem trabalhar paralelamente, sem esperar por outros. Quando eles trabalham num mesmo arquivo, a maioria das alterações não se sobrepoem; conflitos são pouco frequentes. E na maioria das vezes o tempo que leva para resolver os conflitos é muito menor que o tempo perdido em um sistema de alocação.</p><br/>
	<p id="sobre">No final das contas, tudo isso acaba em um ponto crítico: comunicação entre os usuários. Quando os usuários não se comunicam direito, aumenta-se os conflitos sintáticos e semênticos. Nenhum sistema pode forçar uma perfeita comunicação, nenhum sistema pode detectar conflitos de semântica. Então não há porque se entusiasmar com falsas promessas de que um sistema de alocação evitará conflitos; na prática, alocações parecem restringir a produtividade mais que qualquer outra cosa.</p><br/>
	<p id="sobre">Existe uma situação em comum onde o modelo alocar-modificar-desalocar se torna melhor, e é com arquivos que não são unificáveis. Por exemplo, se seu repositório contém alguns arquivos de imagens, e duas pessoas mudam a imagem ao mesmo tempo, não há nenhuma maneira de combinar as alterações. Ou Harry ou Sally perderá sua alteração.</p>
	<p id="autor">
		<a href="http://svnbook.red-bean.com/en/1.7/svn.basic.version-control-basics.html" target="_blank">Subversion 1.7</a>
	</p>
</div>
<div class="postagem">
	<h2 class="titulo-postagem">Jenkins</h2>
	<p class="hora-data">23/09/2016 11:02</p>
	<h5 class="titulo-postagem">Construir grandes coisas em qualquer escala</h5><br/>
	<p id="sobre">O servidor de automação open source líder, Jenkins fornece centenas de plugins para apoiar construção, implantação e automatização de qualquer projeto.</p>
	<h3>Integração Contínua e de Distribuição Contínua</h3>
	<p id="sobre">Como um servidor de automação extensível, Jenkins pode ser usado como um servidor de CI simples ou virado para dentro do cubo entrega contínua para qualquer projeto.</p>
	<h3>Instalação fácil</h3>
	<p id="sobre">Jenkins é um programa baseado em Java independente, pronto para executar out-of-the-box, com pacotes para Windows, Mac OS X e outros sistemas operacionais Unix-like.</p>
	<h3>Fácil configuração</h3>
	<p id="sobre">Jenkins pode ser facilmente instalado e configurado através de sua interface web, que inclui verificações de erro on-the-fly e ajuda embutido.</p>
	<h3>Plugins</h3>
	<p id="sobre">Com centenas de plugins no Centro Update, Jenkins integra com praticamente todas as ferramentas na integração contínua e toolchain entrega contínua.</p>
	<h3>Extensível</h3>
	<p id="sobre">Jenkins pode ser estendido através da sua arquitetura de plugins, proporcionando quase infinitas possibilidades para o que Jenkins pode fazer.</p>
	<h3>Distribuído</h3>
	<p id="sobre">Jenkins pode facilmente distribuir o trabalho entre várias máquinas, ajudando unidade constrói, testes e implementações em múltiplas plataformas mais rápidas.</p>
	<p id="autor">
		<a href="https://jenkins.io" target="_blank">Jenkins</a>
	</p>
</div>